//
//  tmp.h
//  HalconLib
//
//  Created by FoLeakey on 7/1/16.
//  Copyright (c) 2016 IntelligentGroup. All rights reserved.
//

#ifndef HalconLib_tmp_h
#define HalconLib_tmp_h

///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 12.0.2
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure
void action()
{
    
    // Local iconic variables
    HObject  ho_Image, ho_ModelRegion, ho_TemplateImage;
    HObject  ho_ModelContours, ho_TransContours, ho_RectifiedImage;
    
    // Local control variables
    HTuple  hv_ModelID, hv_ModelRegionArea, hv_RefRow;
    HTuple  hv_RefColumn, hv_HomMat2D, hv_TestImages, hv_T;
    HTuple  hv_Row, hv_Column, hv_Angle, hv_Scale, hv_Score;
    HTuple  hv_I, hv_AlignmentHomMat2D, hv_RectificationHomMat2D;
    
    SetSystem("border_shape_models", "false");
    
    ReadImage(&ho_Image, "/vault/AOI_HALCON/TrainImage/Z/Train_Image_01.bmp");
    
    GenRectangle1(&ho_ModelRegion, 234.602, 971.35, 907.127, 1275.36);
    
    ReduceDomain(ho_Image, ho_ModelRegion, &ho_TemplateImage);
    
    CreateScaledShapeModel(ho_TemplateImage, 4, HTuple(0).TupleRad(), HTuple(360).TupleRad(),
                           HTuple(0.3318).TupleRad(), 0.8, 1.2, 0.0029, (HTuple("point_reduction_high").Append("no_pregeneration")),
                           "use_polarity", ((HTuple(40).Append(150)).Append(5)), 3, &hv_ModelID);
    
    GetShapeModelContours(&ho_ModelContours, hv_ModelID, 1);
    
    AreaCenter(ho_ModelRegion, &hv_ModelRegionArea, &hv_RefRow, &hv_RefColumn);
    VectorAngleToRigid(0, 0, 0, hv_RefRow, hv_RefColumn, 0, &hv_HomMat2D);
    AffineTransContourXld(ho_ModelContours, &ho_TransContours, hv_HomMat2D);
    
    if (HDevWindowStack::IsOpen())
        DispObj(ho_Image, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"green");
    if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
        DispObj(ho_ModelRegion, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
        DispObj(ho_TransContours, HDevWindowStack::GetActive());
    // stop(...); only in hdevelop
    
    hv_TestImages.Clear();
    hv_TestImages[0] = "/vault/AOI_HALCON/TrainImage/AB/Train_Image_01.bmp";
    hv_TestImages[1] = "/vault/AOI_HALCON/TrainImage/B/Train_Image_01.bmp";
    hv_TestImages[2] = "/vault/AOI_HALCON/TrainImage/BG/Train_Image_01.bmp";
    hv_TestImages[3] = "/vault/AOI_HALCON/TrainImage/C/Train_Image_01.bmp";
    hv_TestImages[4] = "/vault/AOI_HALCON/TrainImage/CR/Train_Image_01.bmp";
    hv_TestImages[5] = "/vault/AOI_HALCON/TrainImage/CZ/Train_Image_01.bmp";
    hv_TestImages[6] = "/vault/AOI_HALCON/TrainImage/D/Train_Image_01.bmp";
    hv_TestImages[7] = "/vault/AOI_HALCON/TrainImage/DK/Train_Image_01.bmp";
    hv_TestImages[8] = "/vault/AOI_HALCON/TrainImage/E/Train_Image_01.bmp";
    hv_TestImages[9] = "/vault/AOI_HALCON/TrainImage/F/Train_Image_01.bmp";
    hv_TestImages[10] = "/vault/AOI_HALCON/TrainImage/GR/Train_Image_01.bmp";
    hv_TestImages[11] = "/vault/AOI_HALCON/TrainImage/H/Train_Image_01.bmp";
    hv_TestImages[12] = "/vault/AOI_HALCON/TrainImage/HB/Train_Image_01.bmp";
    hv_TestImages[13] = "/vault/AOI_HALCON/TrainImage/IS/Train_Image_01.bmp";
    hv_TestImages[14] = "/vault/AOI_HALCON/TrainImage/KH/Train_Image_01.bmp";
    hv_TestImages[15] = "/vault/AOI_HALCON/TrainImage/MG/Train_Image_01.bmp";
    hv_TestImages[16] = "/vault/AOI_HALCON/TrainImage/N/Train_Image_01.bmp";
    hv_TestImages[17] = "/vault/AOI_HALCON/TrainImage/PO/Train_Image_01.bmp";
    hv_TestImages[18] = "/vault/AOI_HALCON/TrainImage/RO/Train_Image_01.bmp";
    hv_TestImages[19] = "/vault/AOI_HALCON/TrainImage/RS/Train_Image_01.bmp";
    hv_TestImages[20] = "/vault/AOI_HALCON/TrainImage/S/Train_Image_01.bmp";
    hv_TestImages[21] = "/vault/AOI_HALCON/TrainImage/SF/Train_Image_01.bmp";
    hv_TestImages[22] = "/vault/AOI_HALCON/TrainImage/SL/Train_Image_01.bmp";
    hv_TestImages[23] = "/vault/AOI_HALCON/TrainImage/T/Train_Image_01.bmp";
    hv_TestImages[24] = "/vault/AOI_HALCON/TrainImage/TA/Train_Image_01.bmp";
    hv_TestImages[25] = "/vault/AOI_HALCON/TrainImage/TH/Train_Image_01.bmp";
    hv_TestImages[26] = "/vault/AOI_HALCON/TrainImage/TQ/Train_Image_01.bmp";
    hv_TestImages[27] = "/vault/AOI_HALCON/TrainImage/TU/Train_Image_01.bmp";
    hv_TestImages[28] = "/vault/AOI_HALCON/TrainImage/US/Train_Image_01.bmp";
    hv_TestImages[29] = "/vault/AOI_HALCON/TrainImage/Z/Train_Image_01.bmp";
    for (hv_T=0; hv_T<=29; hv_T+=1)
    {
        
        ReadImage(&ho_Image, HTuple(hv_TestImages[hv_T]));
        
        FindScaledShapeModel(ho_Image, hv_ModelID, HTuple(0).TupleRad(), HTuple(360).TupleRad(),
                             0.8, 1.2, 0.8, 0, 0.5, "least_squares", (HTuple(4).Append(1)), 0.75, &hv_Row,
                             &hv_Column, &hv_Angle, &hv_Scale, &hv_Score);
        
        if (HDevWindowStack::IsOpen())
            DispObj(ho_Image, HDevWindowStack::GetActive());
        {
            HTuple end_val31 = (hv_Score.TupleLength())-1;
            HTuple step_val31 = 1;
            for (hv_I=0; hv_I.Continue(end_val31, step_val31); hv_I += step_val31)
            {
                HomMat2dIdentity(&hv_HomMat2D);
                HomMat2dScale(hv_HomMat2D, HTuple(hv_Scale[hv_I]), HTuple(hv_Scale[hv_I]),
                              0, 0, &hv_HomMat2D);
                HomMat2dRotate(hv_HomMat2D, HTuple(hv_Angle[hv_I]), 0, 0, &hv_HomMat2D);
                HomMat2dTranslate(hv_HomMat2D, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]),
                                  &hv_HomMat2D);
                AffineTransContourXld(ho_ModelContours, &ho_TransContours, hv_HomMat2D);
                if (HDevWindowStack::IsOpen())
                    SetColor(HDevWindowStack::GetActive(),"green");
                if (HDevWindowStack::IsOpen())
                    DispObj(ho_TransContours, HDevWindowStack::GetActive());
                // stop(...); only in hdevelop
            }
        }
        
        {
            HTuple end_val42 = (hv_Score.TupleLength())-1;
            HTuple step_val42 = 1;
            for (hv_I=0; hv_I.Continue(end_val42, step_val42); hv_I += step_val42)
            {
                HomMat2dIdentity(&hv_AlignmentHomMat2D);
                HomMat2dTranslate(hv_AlignmentHomMat2D, -hv_RefRow, -hv_RefColumn, &hv_AlignmentHomMat2D);
                HomMat2dRotate(hv_AlignmentHomMat2D, HTuple(hv_Angle[hv_I]), 0, 0, &hv_AlignmentHomMat2D);
                HomMat2dTranslate(hv_AlignmentHomMat2D, HTuple(hv_Row[hv_I]), HTuple(hv_Column[hv_I]),
                                  &hv_AlignmentHomMat2D);
                
            }
        }
        
        {
            HTuple end_val50 = (hv_Score.TupleLength())-1;
            HTuple step_val50 = 1;
            for (hv_I=0; hv_I.Continue(end_val50, step_val50); hv_I += step_val50)
            {
                HomMat2dIdentity(&hv_RectificationHomMat2D);
                HomMat2dTranslate(hv_RectificationHomMat2D, hv_RefRow-HTuple(hv_Row[hv_I]),
                                  hv_RefColumn-HTuple(hv_Column[hv_I]), &hv_RectificationHomMat2D);
                HomMat2dRotate(hv_RectificationHomMat2D, -HTuple(hv_Angle[hv_I]), hv_RefRow,
                               hv_RefColumn, &hv_RectificationHomMat2D);
                AffineTransImage(ho_Image, &ho_RectifiedImage, hv_RectificationHomMat2D, "constant",
                                 "false");
                
            }
        }
    }
    
    // stop(...); only in hdevelop
    ClearShapeModel(hv_ModelID);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
    UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
    LockMutex(gStartMutex);
    action();
    CFRunLoopStop(CFRunLoopGetMain());
    return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
    Herror                error;
    CFRunLoopTimerRef     Timer;
    CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };
    
    CreateMutex("type","sleep",&gStartMutex);
    LockMutex(gStartMutex);
    
    error = HpThreadHandleAlloc(&gActionThread);
    if (H_MSG_OK != error)
    {
        fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
        exit(1);
    }
    
    error = HpThreadCreate(gActionThread,0,apple_action);
    if (H_MSG_OK != error)
    {
        fprintf(stderr,"HpThreadCreate failed: %d\n", error);
        exit(1);
    }
    
    Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                                 CFAbsoluteTimeGetCurrent(),0,0,0,
                                 timer_callback,&TimerContext);
    if (!Timer)
    {
        fprintf(stderr,"CFRunLoopTimerCreate failed\n");
        exit(1);
    }
    CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
    CFRunLoopRun();
    CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
    CFRelease(Timer);
    
    error = HpThreadHandleFree(gActionThread);
    if (H_MSG_OK != error)
    {
        fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
        exit(1);
    }
    
    ClearMutex(gStartMutex);
    return 0;
}
#endif

int main(int argc, char *argv[])
{
    // Default settings used in HDevelop (can be omitted) 
    int ret=0;
    SetSystem("width", 512);
    SetSystem("height", 512);
    
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__)
    XInitThreads();
#endif
    
#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
    return ret;
}

#endif


#endif




#endif
